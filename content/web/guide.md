/*
Title : 开发向导
Sort : 1
*/

## 1.安装与设置

#### 创建一个帐号

首先,你需要[ 注册一个Wilddog帐号 ](https://www.wilddog.com/account/signup). 一个App会被创建.每一个App都有一个独立的域名 `<appid>.wilddogio.com`.你会使用这个url 进行存储和同步数据

在你的Wilddog 控制台里,你可以实时对数据进行创建,管理,删除等操作.同时你可以创建安全规则,管理授权系统.查看统计数据

#### 安装Wilddog

下一步,你需要将Wilddog javascript 客户端引入你的页面,在HTML的`<head>` 中增加一个 `script` 标签.推荐直接通过我们的 CDN 引入:

```html
<script src="https://cdn.wilddog.com/js/client/current/wilddogio.js">
```

## 2.了解数据

#### 数据是一棵 JSON 树

所有的数据都存储在各异 JSON 对象中,没有任何表的概念,当你把数据添加到这棵json 树中,这些数据就变成这棵树的子树.比如,我们在`users/mchen` 下增加 `widget` 下,我们的数据是这样的:
``` json
{
  "users": {
    "mchen": {
      "friends": { "brinchen": true },
      "name": "Mary Chen",
      // our child node appears in the existing JSON tree
      "widgets": { "one": true, "three": true }
    },
    "brinchen": { ... },
    "hmadi": { ... }
  }
}

```



#### 创建一个Wilddog 对象引用

在html中读写wilddog数据,需要创建一个Wilddog对象引用, 要操作和同步哪些数据取决于创建 Wilddog对象引用时传入的URL
```js
Wilddog('https://demoblog.wilddogio.com/web/data');
```
创建一个Wilddog引用并不是直接访问这个URL,或创建一个连接.数据直到需要的时候才会传输.一旦这个数据被查询,这个数据会一直与服务端保持一致.

> **数据限制**
> 一个子节点的key不能长于768byte,不能深于32层,不能包含ASCII 控制字符0-31 和127 .另外,不能包含以下字符 `.` `$` `#` `[` `]` `/`

你可以直接访问一个子节点:
``` js
Wilddog("https://demoblog.wilddogio.com/web/data/users/mchen/name");
```


你还可以通过 child接口进行相对路径访问:


```js
var rootRef = Wilddog('https://demoblog.wilddogio.com/web/data');
rootRef.child('users/mchen/name');

```

#### Wilddog 中的数组

Wilddog并不天然支持数组,当我们想存数组时,我们把数组变成对象:

``` js
//原始数据
['hello', 'world']
// 我们存储的数据
{0: 'hello', 1: 'world'}

```

#### 限制和约束

| 描述 | 约束 | 备注 |
| --- | --- | --- |
| 树的深度 |32 | |
|key的长度 | 768byte | UTF-8 编码,不能包含 `.` `$` `#` `[` `]` `/` 和 ASCII 控制字符 |
| 一个叶子节点的数据大小 | 10mb | UTF-8 编码 |
| 通过SDK写入的数据大小限制 | 16mb | UTF-8 编码 |
| 通过 REST 写入数据大小限制 |256mb | |
| 一次能读取的节点 |1亿 | |     


## 3.保存数据

#### 保存数据的方式
|method |description | 
| --- |---- | 
| set() | 写入和替换当前路径的数据 |
| update() |修改部分子节点的数据 |
| push() | 在当前节点下新增一个数据,数据的key随机生成 |

#### 用 set() 写数据
set 是 Wilddog 最基本的写数据操作.set() 设置当前节点的值,如果当前节点已经存在值,set 会将旧值替换成新值.为了理解set的工作原理,我们创建一个简单博客app,这个博客的app储存在这里
```js
var ref =Wilddog("https://demoblog.wilddogio.com/web/saving-data/fireblog");
```
我们储存一些数据到Wilddog,我们用一个唯一的username 保存用户.我们同时储存他们的全称和生日.因为每一个用户都有一个唯一的 username,所以我们使用set 而不是push
首先,我们创建一个引用,然后我们用set储存数据,set可以传入 `string,number,boolean,object` 类型:
```js
var usersRef = ref.child("users");
usersRef.set({
  alanisawesome: {
    date_of_birth: "June 23, 1912",
    full_name: "Alan Turing"
  },
  gracehop: {
    date_of_birth: "December 9, 1906",
    full_name: "Grace Hopper"
  }
});

```

这时,数据被嵌套保存到了响应的位置上,
完成上面的过程,你还可以直接这样做:

```js
usersRef.child("alanisawesome").set({
  date_of_birth: "June 23, 1912",
  full_name: "Alan Turing"
});
usersRef.child("gracehop").set({
  date_of_birth: "December 9, 1906",
  full_name: "Grace Hopper"
});

```
这两种方式的区别是,如果 /user 下面原来有数据的时候,第一种方式会把数据全部覆盖掉,而第二种方式只会覆盖 `alanisawesome` 和`gracehop` 两个子节点.



#### 更新已经存在的数据

如果你想同时更新多个子节点,而不覆盖其他的子节点,你可以使用 update() 方法:


```js
var hopperRef = usersRef.child("gracehop");
hopperRef.update({
  "nickname": "Amazing Grace"
});
```

这样会更新 Grace的数据,更新她的 `nickname` .如果我们用 `set` 而不是 `update` ,`date_of_birth` 和 `full_name` 都会被删除



#### 保存一个列表
当多个用户同时试图在一个节点下新增一个子节点的时候,这时,数据就会被重写,覆盖.
为了解决这个问题,Wilddog push()采用了生成唯一ID 作为key的方式.通过这种方式,多个用户同时在一个节点下面push 数据,他们的key一定是不同的.这个key是通过一个基于时间戳和随机的算法生成的.wilddog采用了足够多的位数保证唯一性.

用户可以用post 向 blog app 中写新内容


```js

var postsRef = ref.child("posts");
  postsRef.push({
    author: "gracehop",
    title: "Announcing COBOL, a New Programming Language"
  });
  postsRef.push({
    author: "alanisawesome",
    title: "The Turing Machine"
  });

```

产生的数据有一个唯一ID:
```js
{
  "posts": {
    "-JRHTHaIs-jNPLXO": {
      "author": "gracehop",
      "title": "Announcing COBOL, a New Programming Language"
    },
    "-JRHTHaKuITFIhnj": {
      "author": "alanisawesome",
      "title": "The Turing Machine"
    }
  }
}

```

>**获取唯一ID**
>调用push 会返回一个引用,这个引用指向新增数据所在的节点.你可以通过调用 `key()` 来获取这个唯一ID
>
> ```js
> // Generate a reference to a new location and add some data using push()
>var newPostRef = postsRef.push({
>  author: "gracehop",
>  title: "Announcing COBOL, a New Programming Language"
>});
>
>// Get the unique ID generated by push()
>var postID = newPostRef.key();
> ```



## 4.查询数据
到目前为止,我们已经了解到如何向Wilddog中保存数据,现在我们来看看如何查询数据

>Wilddog 查询数据的方式是绑定一个异步监听callback,每当数据被第一次查询或者数据发生变化,这个监听callback都会被触发

重新看blog的例子,读取post数据我们可以这么做:


```js
// Get a reference to our posts
var ref = new Firebase("https://demo-blog.wilddogio.com/web/saving-data/fireblog/posts");

// Attach an asynchronous callback to read the data at our posts reference
ref.on("value", function(snapshot) {
  console.log(snapshot.val());
}, function (errorObject) {
  console.log("The read failed: " + errorObject.code);
});

```

`on()` 的参数是一个 事件类型 和一个接收数据的回调函数,回调函数接收 Snapshot类型 作为参数.这个例子中我们用 `'value'` 作为事件类型,我们还可以使用以下四中事件类型

#### 数据类型

> **数据事件**
> 'value' 用来读取当前节点的静态数据快照, `value` 事件在`on` 被调用的时候被触发一次,之后每次数据发生改变都会被触发.当回调函数被调用时候,当前节点下所有数据的静态快照会被传入作为参数


> **子节点被添加事件**
> 当新的子节点被添加到当前节点, `child_added` 事件被触发,不像`value` 事件,在 'child_added' 事件的回调函数中传入的参数仅仅是被添加的那个节点的数据静态快照.
>如果我们仅仅关心新增节点,我们可以 使用 `child_added`:
```js
// Get a reference to our posts
var ref = new Firebase("https://demoblog.wilddogio.com/web/saving-data/fireblog/posts");

// Retrieve new posts as they are added to Firebase
ref.on("child_added", function(snapshot) {
  var newPost = snapshot.val();
  console.log("Author: " + newPost.author);
  console.log("Title: " + newPost.title);
});
```
> **子节点被改变事件**
> 当子节点发生了改变,`child_changed`  事件被触发, `child_changed` 的事件回调函数中传入的参数是子节点改变后的数据的静态快照
> **子节点被删除事件**
> 当子节点被删除,`child_removed` 事件被触发, `child_removed`与 `child_added` `child_changed` 配合使用,可以>覆盖所有的数据变化

#### 取消事件绑定

通过off接口取消一个回调函数对事件的绑定:
```js
ref.off("value", originalCallback);
```

## 5.组织数据
使用NOSQL 存储,需要有一些技巧,我们需要了解数据如何被读取

#### 避免层级过深

尽管Json可以任意的组织数据,但不同的方式对读取性能的影响是很大的,Wilddog的工作方式是当你查询某个节点,Wilddog会查询这个节点下的所有子节点,所以,如果数据过于集中嵌套,读取一个父级节点可能读取非常多的子节点,造成流量和cpu的浪费.

<div class="alert"> 我们不推荐这种实践 </div>
```js
{
    // a poorly nested data architecture, because
    // iterating "rooms" to get a list of names requires
    // potentially downloading hundreds of megabytes of messages
    "rooms": {
      "one": {
        "name": "room alpha",
        "type": "private",
        "messages": {
          "m1": { "sender": "mchen", "message": "foo" },
          "m2": { ... },
          // a very long list of messages
        }
      }
    }
  }
```

#### 使数据扁平化

如果数据分布到不同的path,会大大提高查询性能:

```js

{
    // rooms contains only meta info about each room
    // stored under the room's unique ID
    "rooms": {
      "one": {
        "name": "room alpha",
        "type": "private"
      },
      "two": { ... },
      "three": { ... }
    },

    // room members are easily accessible (or restricted)
    // we also store these by room ID
    "members": {
      // we'll talk about indices like this below
      "one": {
        "mchen": true,
        "hmadi": true
      },
      "two": { ... },
      "three": { ... }
    },

    // messages are separate from data we may want to iterate quickly
    // but still easily paginated and queried, and organized by room ID
    "messages": {
      "one": {
        "m1": { "sender": "mchen", "message": "foo" },
        "m2": { ... },
        "m3": { ... }
      },
      "two": { ... },
      "three": { ... }
    }
  }
  
```

#### 使数据可扩展化

如果我们只关注单向的关系,并且关系非常稳定,我们可以把数据简单的嵌套起来:
```
{
    "users": {
      "john": {
         "todoList": {
            "rec1": "Walk the dog",
            "rec2": "Buy milk",
            "rec3": "Win a gold medal in the Olympics"
         }
      }
    }
  }
```

但是如果关系变成双向,就像下面的例子,用户可以属于某些组,组也属于某些用户,无论使用用户来嵌套组还是使用组来嵌套用户都是不可行的.
需求通常要求通过用户来查询组,并且可以通过组来查询用户,我们可以用一个数据索引来解决这个问题

```js
// An index to track Mary's memberships
  {
    "users": {
      "mchen": {
        "name": "Mary Chen",
        // index Mary's groups in her profile
        "groups": {
           // the value here doesn't matter, just that the key exists
           "alpha": true,
           "charlie": true
        }
      },
      ...
    },
    "groups": { ... }
  }

```
每一个用户下面有一个子节点`'groups'` 来作为这个用户加入的组的索引,同样,每一个组下面也有用户的索引.这样做的好吃是大大的提高查询性能






## 6.了解安全
安全是一个大的话题,并且非常重要,通常在app开发中,这一部分是最难的,Wilddog让这一切变得简单,Wilddog使用一种配置语言来配置安全规则

#### 认证

用户ID是一个非常重要概念,不同的用户拥有不同的数据和不同的权限,比如,在一个聊天程序,	每一条消息关联它的创造者,用户可以删除自己的消息,而不能删除别人的,让APP变得安全的第一步是用户认证

Wilddog 提供了以下用户认证的方式
* 集成微博 和其他 OAuth访问
* Email,密码登录,并且提供用户管理
* 匿名用户访问
* 第三方Token登录

#### 授权

知道用户的身份只是安全的一部分,一旦你知道谁在访问数据,你需要一种方式来控制访问权限
Wilddog提供了一种描述语言,你能在控制面板里的安全规则 tab 编辑.
这些安全规则让你可以控制管理数据的访问规则.规则级联应用到其子节点

```js
{
  "rules": {
    "foo": {
      ".read": true,
      ".write": false
    }
  }
}

```

这个例子允许所有人访问 `foo`

安全规则包含一系列内置对象,和函数.你可以利用这些函和对象构建表达式,可以灵活的控制用户访问.最重要的一个内置对象是 auth,auth在app的用户认证的时候生成, auth包含一系列对象,包含一个唯一ID. auth.uid

auth 变量是很多安全规则的基础

```js
{
  "rules": {
    "users": {
      "$user_id": {
        ".write": "$user_id === auth.uid"
      }
    }
  }
}
```


这个规则保证 用户只能访问 users 下 与 uid 同名的节点




## 7.认证

绝大多数应用都需要知道用户的身份,让服务端知道用户身份的过程叫做认证.Wilddog提供了一系列认证方式,简单方便.




